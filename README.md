# MSDialogueSystemInky
Новая, высокопроизводительная и полностью индивидуально настраиваемая для любой игры система диалогов, с использованием Inky.

Плюсы:

+ Высокая производительность
+ Занимает мало места при билде
+ Можно настроить всё и вся под любые нужды
+ Лёгкая для модификаций и расширения

Минусы:

+ Не удобно писать сами диалоги
+ Вполне возможное прекращение поддержки Inky и его интеграции в юнити
+ Очевидная невозможность обращения напрямую к объектам на сцене

**Инструкция**

**1. Скачиваем Inky - https://github.com/inkle/inky и импортируем Ink Integration в Unity из Asset Store**

**2. Импортируем MSDialogueSystemInky**

**3. Настриваем проект:**
     **3.1  Настриваем Canvas под игру, или берём готовый из папки Prefabs*
     **3.2 Создаём пустышку на которой будут весеть все нужные скрипты для контроля, и накидываем туда скрипт DialogueController (Всё остальное необходимое для его работы накинется само. **Но важно помнить что другие скрипты, которые не необходимы для работы контроллера 
     (такие как UIEffects), нужно докидовать самому)***
     ****3.3 Класс DialogueWindowBase отвечает за управление окна диалога и текста. По стандарту он может указывать имя, текст, и скорость текста. Если же нужно больше контроля(звук при печатаньи, смена фона, разные еффекты на экране и т.д), нужно наследоватся от 
     DialogueWindowBase и добавить или изменить функционал. Но есть встроенный наследованный класс DialogueWindow, который всё это делает, поэтому моэно использовать его. Наследованный класс добавляем на тот же обьект где есть DialogueController***
     **3.4 Перекидываем все ссылки и указываем все значения в контроллере*
     **3.5 Можно наследоваться от DialogueController, и изменить или добавить функционал*
     
**4. Открываем Inky, и создаём диалог(или просто сохраняем пустой файл)**

**5. Создаём точку входа в диалог(например НПС). На него накидываем готовый класс NPCTrigger в папке Triggers, или же, что лучше, делаем свой. В нём через обращение к DialogueController вызываем метод StartDialogue, и передаём ему JSON файл диалога(он создаёться сам при добавлении ink файла в проект)**

**В С Ё**


**Инструкция по Inky, тегам и коммандам**

Стандартный синтаксис я не буду тут писать, распишу то что добавил я

**Теги**

*Дефолтная тема в программе с помощью которой можно вызывать нужный функционал при **начале** обработки строки.
Просто в конце строки пишем "#", название(ключ) тега после, через ":" пишем значение.
К приемру "#speaker:Денис" или можно указать заранее приготовленную переменную - "#speaker:{д}"*

***Полный список ТОЛЬКО тегов на данный момент:***
*speaker - указывает имя говорящего


**Комманды**

*Моя розработка. Тоже что и теги, только можно вызвать в нужный момент при выводе текста. Для написании комманды, пишем в любом месте строки "/0 /0", и внутри этой хуйни пишем комманду(пишуться также как и теги, только без "#").
В одной такой структуре можно писать сколько угодно комманд, главное разделить их с помощью ";". Пример: "идите нахуй/0 sound:glass break ; sound:fall scream ; uieffect:Shake() /0 (съебал в окно с 5 этажа)"*

***Полный список ТОЛЬКО комманд на данный момент:***
*delay - делает задержку в выводе текста на указонное время


***Полный список и тегов и комманд:***
*cd - указывает скорость показа текста
*method - бета версия, лучше не трогать
*bg - указывает фон
*bgmusic - указывает музыку на фоне
*typesound - указывает звук при печатаньи
*sound - просто воспроизводит указанный звук один раз
*uieffect - вызывает визуальные эффекты на UI. После ":" нужно указать точное имя метода в классе UIEffects, после в скобочках правильные агрументы. Пример "#uieffect:Shake()" или "#uieffect:Shake(1,500)".
           Оно само найдёт нужный метод с нужными аргументами и вызовет его. Можно добавить свои еффекти в классе UIEffects.


**Новые теги и комманды можно создавать самому. Для этого нужно создать скрипт ОБЯЗЯТЕЛЬНО ВНУТРИ СБОРКИ СИСТЕМЫ ДИАЛОГОВ, желательно внутри папки Tags&Cmds, так как код автоматически находит все теги и комамнды но только ВНУТРИ СБОРКИ.
После наследуемся от интерфейсов IDialogueTag, IDialogueCommand или от двух сразу. И реализуем всё необходимое**
*Keyword - имя(ключ) для вызова из Inky
*ExecuteWhenSkipped - будет ли выполнятся комманда при скипе реплики (если комманда уже выполнилась она выполняться второй раз при скипе уже не будет, что бы тут не указывать)
*Calling(string value) - сам функционал тега/комманды. Value - значение указанное после ":" в теге/комманде в Inky. Его можно ковертировать в другие типы данных, таких как float или что то куда сложнее,как например имя и параметры метода как в uieffect, если надо

**В С Ё**
